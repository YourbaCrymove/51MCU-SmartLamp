C51 COMPILER V9.54   KEYINPUT                                                              10/19/2025 12:00:09 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE KEYINPUT
OBJECT MODULE PLACED IN .\Objects\keyInput.obj
COMPILER INVOKED BY: D:\keil_v5\C51\BIN\C51.EXE Driver\keyInput.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Users;.\Driver) DEBU
                    -G OBJECTEXTEND PRINT(.\Listings\keyInput.lst) OBJECT(.\Objects\keyInput.obj)

line level    source

   1          #include "keyInput.h"
   2          #include <regx52.h>
   3          #include "keyConfig.h"
   4          
   5          // 全局变量定义
   6          keyState currentKeyState = KEY_STATE_IDLE;    // 当前按键状态机状态，初始为空闲状态
   7          unsigned char keyDebounceTimer = 0;           // 消抖计时器，用于计算消抖时间
   8          unsigned char confirmedKey = 0;               // 保存确认的按键值，确保返回正确的按键编
             -号
   9          
  10          /**
  11           * @brief 扫描按键物理状态
  12           * @return 按键编号：1-4对应不同按键，0表示无按键按下
  13           * @note 此函数仅读取IO口状态，不进行任何消抖处理
  14           */
  15          unsigned char keyScan(void) {
  16   1          if(P3_1 == 0) return 1;             // 按键1
  17   1          if(P3_0 == 0) return 2;             // 按键2
  18   1          if(P3_2 == 0) return 3;             // 按键3
  19   1          if(P3_3 == 0) return 4;             // 按键4
  20   1          return 0;           // 无按键
  21   1      }
  22          
  23          /**
  24           * @brief 读取经过消抖处理的按键值
  25           * @return 有效的按键编号：1-4对应不同按键，0表示无有效按键事件
  26           * @note 使用状态机实现按键消抖，确保每次按键只触发一次
  27           */
  28          unsigned char keyRead(void) {
  29   1          unsigned char keyNumber = 0;      // 要返回的按键值，默认为0（无按键）
  30   1          unsigned char currentKey = 0;     // 当前扫描到的按键值
  31   1          
  32   1          // 扫描当前按键状态
  33   1          currentKey = keyScan();
  34   1          
  35   1          // 按键状态机处理
  36   1          switch(currentKeyState) {
  37   2              case KEY_STATE_IDLE:    // 空闲状态：按键未按下
  38   2                  // 检测到有按键按下（非0表示有按键）
  39   2                  if(currentKey != 0) {
  40   3                      // 转移到按下消抖状态，开始消抖处理
  41   3                      currentKeyState = KEY_STATE_DEBOUNCE_PRESS;
  42   3                      confirmedKey = currentKey;  // 记录当前按下的按键，用于后续验证
  43   3                  }            
  44   2                  break;
  45   2                  
  46   2              case KEY_STATE_DEBOUNCE_PRESS:     // 按下消抖状态：确认按键真的按下
  47   2                  // 消抖计时器递增，模拟时间流逝
  48   2                  keyDebounceTimer++;
  49   2                  
  50   2                  // 检查是否达到消抖时间要求
  51   2                  if(keyDebounceTimer >= DEBOUNCE_TIME) {
  52   3                      keyDebounceTimer = 0;  // 重置计时器
  53   3                      
C51 COMPILER V9.54   KEYINPUT                                                              10/19/2025 12:00:09 PAGE 2   

  54   3                      // 重新扫描按键状态，确认消抖后的实际状态
  55   3                      currentKey = keyScan();
  56   3                      
  57   3                      // 验证是否仍然是之前记录的按键被按下（确认不是抖动）
  58   3                      if(confirmedKey == currentKey) {
  59   4                          // 确认按键有效按下，转移到按下确认状态
  60   4                          currentKeyState = KEY_STATE_PRESSED;
  61   4                          keyNumber = confirmedKey;  // 返回确认的按键值给调用者
  62   4                      } else {
  63   4                          // 按键状态不一致，判断为机械抖动，返回空闲状态
  64   4                          currentKeyState = KEY_STATE_IDLE;
  65   4                      }
  66   3                  }
  67   2                  break;
  68   2                  
  69   2              case KEY_STATE_PRESSED:    // 按下确认状态：处理按键按下逻辑
  70   2                  // 等待按键释放，这里不返回按键值（按键值已在消抖状态返回）
  71   2                  // 检测按键是否释放（扫描值为0表示释放）
  72   2                  if(keyScan() == 0) {
  73   3                      // 按键释放，转移到释放消抖状态
  74   3                      currentKeyState = KEY_STATE_DEBOUNCE_RELEASE;
  75   3                  }
  76   2                  break;
  77   2              
  78   2              case KEY_STATE_DEBOUNCE_RELEASE:    // 释放消抖状态：确认按键真的释放
  79   2                  // 释放消抖计时器递增
  80   2                  keyDebounceTimer++;
  81   2                  
  82   2                  // 检查是否达到消抖时间要求
  83   2                  if(keyDebounceTimer >= DEBOUNCE_TIME) {
  84   3                      keyDebounceTimer = 0;  // 重置计时器
  85   3                      
  86   3                      // 重新扫描按键状态，确认是否真的释放
  87   3                      if(keyScan() == 0) {
  88   4                          // 确认按键完全释放，返回空闲状态，准备检测下一次按键
  89   4                          currentKeyState = KEY_STATE_IDLE;
  90   4                      } else {
  91   4                          // 按键仍然被按下，可能是长按或抖动，保持释放消抖状态继续
             -待
  92   4                          // 注意：不要回到PRESSED状态，避免重复触发按键事件
  93   4                          currentKeyState = KEY_STATE_DEBOUNCE_RELEASE;
  94   4                      }
  95   3                  }
  96   2                  break;
  97   2          }
  98   1          
  99   1          // 返回按键值（仅在按下消抖状态确认后会返回非0值）
 100   1          return keyNumber;
 101   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    125    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
