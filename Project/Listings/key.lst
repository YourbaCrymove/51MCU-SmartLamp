C51 COMPILER V9.54   KEY                                                                   10/24/2025 19:25:03 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\Objects\key.obj
COMPILER INVOKED BY: D:\keil_v5\C51\BIN\C51.EXE ..\Driver\key\key.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Common;..\Core;..
                    -\Driver\nixie;..\Driver\xpt2046;..\Driver\key;..\Driver\timer;..\Driver\lightControl) DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\key.lst) OBJECT(.\Objects\key.obj)

line level    source

   1          /**
   2           * @file    key.c
   3           * @brief   按键驱动实现文件
   4           * @details 基于状态机的按键消抖算法，支持4个独立按键
   5           * @author  智能台灯项目组
   6           * @version 1.0
   7           * @date    2025-10-24
   8           */
   9          #include "key.h"
  10          #include <regx52.h>
  11          #include "config.h"
  12          
  13          // 全局变量定义
  14          static keyState currentKeyState = KEY_STATE_IDLE;    // 当前按键状态机状态，初始为空闲状
             -
  15          static unsigned char keyDebounceTimer = 0;           // 消抖计时器，用于计算消抖时间
  16          static unsigned char confirmedKey = 0;               // 保存确认的按键值，确保返回正确的
             -键编号
  17          
  18          /**
  19           * @brief 扫描按键物理状态
  20           * @return 按键编号：1-4对应不同按键，0表示无按键按下
  21           * @note 此函数仅读取IO口状态，不进行任何消抖处理
  22           */
  23          unsigned char keyScan(void) {
  24   1          if(P3_1 == 0) return 1;             // 按键1
  25   1          if(P3_0 == 0) return 2;             // 按键2
  26   1          if(P3_2 == 0) return 3;             // 按键3
  27   1          if(P3_3 == 0) return 4;             // 按键4
  28   1          return 0;           // 无按键
  29   1      }
  30          
  31          /**
  32           * @brief 读取经过消抖处理的按键值
  33           * @return 有效的按键编号：1-4对应不同按键，0表示无有效按键事件
  34           * @note 使用状态机实现按键消抖，确保每次按键只触发一次
  35           */
  36          unsigned char keyRead(void) {
  37   1          unsigned char keyNumber = 0;      // 要返回的按键值，默认为0（无按键）
  38   1          unsigned char currentKey = 0;     // 当前扫描到的按键值
  39   1          
  40   1          // 扫描当前按键状态
  41   1          currentKey = keyScan();
  42   1          
  43   1          // 按键状态机处理
  44   1          switch(currentKeyState) {
  45   2              case KEY_STATE_IDLE:    // 空闲状态：按键未按下
  46   2                  // 检测到有按键按下（非0表示有按键）
  47   2                  if(currentKey != 0) {
  48   3                      // 转移到按下消抖状态，开始消抖处理
  49   3                      currentKeyState = KEY_STATE_DEBOUNCE_PRESS;
  50   3                      confirmedKey = currentKey;  // 记录当前按下的按键，用于后续验证
  51   3                  }            
C51 COMPILER V9.54   KEY                                                                   10/24/2025 19:25:03 PAGE 2   

  52   2                  break;
  53   2                  
  54   2              case KEY_STATE_DEBOUNCE_PRESS:     // 按下消抖状态：确认按键真的按下
  55   2                  // 消抖计时器递增，模拟时间流逝
  56   2                  keyDebounceTimer++;
  57   2                  
  58   2                  // 检查是否达到消抖时间要求
  59   2                  if(keyDebounceTimer >= DEBOUNCE_TIME) {
  60   3                      keyDebounceTimer = 0;  // 重置计时器
  61   3                      
  62   3                      // 重新扫描按键状态，确认消抖后的实际状态
  63   3                      currentKey = keyScan();
  64   3                      
  65   3                      // 验证是否仍然是之前记录的按键被按下（确认不是抖动）
  66   3                      if(confirmedKey == currentKey) {
  67   4                          // 确认按键有效按下，转移到按下确认状态
  68   4                          currentKeyState = KEY_STATE_PRESSED;
  69   4                          keyNumber = confirmedKey;  // 返回确认的按键值给调用者
  70   4                      } else {
  71   4                          // 按键状态不一致，判断为机械抖动，返回空闲状态
  72   4                          currentKeyState = KEY_STATE_IDLE;
  73   4                      }
  74   3                  }
  75   2                  break;
  76   2                  
  77   2              case KEY_STATE_PRESSED:    // 按下确认状态：处理按键按下逻辑
  78   2                  // 等待按键释放，这里不返回按键值（按键值已在消抖状态返回）
  79   2                  // 检测按键是否释放（扫描值为0表示释放）
  80   2                  if(keyScan() == 0) {
  81   3                      // 按键释放，转移到释放消抖状态
  82   3                      currentKeyState = KEY_STATE_DEBOUNCE_RELEASE;
  83   3                  }
  84   2                  break;
  85   2              
  86   2              case KEY_STATE_DEBOUNCE_RELEASE:    // 释放消抖状态：确认按键真的释放
  87   2                  // 释放消抖计时器递增
  88   2                  keyDebounceTimer++;
  89   2                  
  90   2                  // 检查是否达到消抖时间要求
  91   2                  if(keyDebounceTimer >= DEBOUNCE_TIME) {
  92   3                      keyDebounceTimer = 0;  // 重置计时器
  93   3                      
  94   3                      // 重新扫描按键状态，确认是否真的释放
  95   3                      if(keyScan() == 0) {
  96   4                          // 确认按键完全释放，返回空闲状态，准备检测下一次按键
  97   4                          currentKeyState = KEY_STATE_IDLE;
  98   4                      } else {
  99   4                          // 按键仍然被按下，可能是长按或抖动，保持释放消抖状态继续
             -待
 100   4                          // 注意：不要回到PRESSED状态，避免重复触发按键事件
 101   4                          currentKeyState = KEY_STATE_DEBOUNCE_RELEASE;
 102   4                      }
 103   3                  }
 104   2                  break;
 105   2          }
 106   1          
 107   1          // 返回按键值（仅在按下消抖状态确认后会返回非0值）
 108   1          return keyNumber;
 109   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.54   KEY                                                                   10/24/2025 19:25:03 PAGE 3   

   CODE SIZE        =    125    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
